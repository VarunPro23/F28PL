(* Coursework template

   Varun Senthil, H00332328          <--- so we know who you are
   F28PL Coursework 2, OCaml        <--- sanity check

   Deadline is 27 November 2020 (end week 11).

   You may assume variables and functions defined in earlier questions
   in your answers to later questions, though you should add comments
   in code explaining this if any clarification might help read your
   code.

   To do this coursework, FORK, THEN CLONE the gitlab project.

   If you do it the other way around, then you'll have cloned *my*
   project (which you can't `git push` to), rather than cloned *your
   fork* of the project (which you can `git push` to).

   Any questions, don't guess: ask.

   This coursework is live exam material so KEEP YOUR ANSWERS PRIVATE. *)

(* Write an essay on the OCaml type system. Be clear, to-the-point, and
   concise. Convince your marker that you understand:

   - Function type signatures.
   - Polymorphism.
   - List types and tuple types (and their differences).
   - OCaml pattern-matching on values (e.g. integers) and structures (e.g. lists).
   - Named and anonymous functions.
   - Recursive functions.
   - Unit and property based tests.

   Include short code-fragments (as in the lectures) to illustrate
   your observations.
   Do this in a literate programming style to include executable code
   to demonstrate the concepts you're writing about, e.g. *)

(* The following function adds two numbers together. It has types ... *)

let add (x:int) (y:int) : int = x + y

(* The following function... *)

(*
Ocaml is a functional programming language. This means that a function maps an input to an output. For the same input, it produces 
the same output, meaning these functions are stateless: they do not maintain any extra information that exiss between usages of the
function. *) 

(*
Signatures

Signatures is a way of defining a function,value,module or class using type only. These are widely used in OCaml programming. These function 
signatures are automatically generated by the interpreter when code is entered. This is used to show type information and much Ocaml documentation 
uses these types of function type signatures. There are two types of function signatures:

   1. Lambda binding :  The types of the varibles that are to be used are specified in the signature.
   2. Inline : The name of the variable is assigned along with its type in the signature.

 Some examples have been given below:
*)

let mult : int -> int -> int =                              (*Specific lambda binding (The types are mentioned)*)
   fun x y -> x*y;;

let mult1 : 'a -> 'b -> 'c =                                (*Unspecific lambda binding (Can take argument of any type)*)
   fun x y -> x*y;;                                         (* This will only take type 'int' since its multiplication *)

let mult2 (x:int)(y:int):int =                              (*Inline*)
   x*y;;


(*
Polymorphism

In Ocaml, polymorphic functions are functions that can have parameters of different types. There are two types of polymorphic functions in Ocaml, lets
have a look  at them.

Ad-hoc polymorphism : it refers to the ability to define a function with the same name but with different types. They are different functions that can 
act in different ways. The compiler chooses one depending on the context. For example:
+ : int -> int -> int  and  + : float -> float -> float.
These both are different functions that work the same way but with different type.[1]

Parametric polymorphism : This type of polymorphism refers to functions that work with arguments of any type. Unlike ad-hoc polymorphism, these functions
work the same way regardless of the type of input. For example:
add_list : 'a list -> 'a list -> 'a list  [1]

Lets have a look at some examples
*)

let rev ((m:'a),(n:'b)):'b * 'a =                        (* This is an example of parametric polymorpism, where any type of argument can be passed but the result is the same *)
   (n,m);;                                                                                                          

(* More tests are there in EssayTests.ml*)

(*
List types and tuple types

Lists:
   Lists are an arbitrary seqeunce with all elements being of the same type. A list is can either be empty or contain a heand and a tail.
   Lists are defined using square brackets [] and elements are separated by semicolons.
   List indexing starts at 0 and are of a fixed size.
   The cons (::) operator is used to add something to a list. [2]
   
   Examples:

      [1;2;3;4]    ->   List of type int
      ["Hello";"World"]  ->  List of type string
      []  ->  Empty list
      1::(2::(3::[]))  ->  This gives us a list like [1;2;3]

Tuples:
   Tuples is a collection of elements. The type is mentioned in the signature of the function. The type of all elements need not be the same.
   Tuples are defined using parenthesis () and elements are separated by commas.
   The syntax for defining a tuple is the '*' sign. [2]

   Examples:

      (1,5.4,true,"Hello")  ->  Tuple that contains an int,float,bool and a string. 
*)
let tuple_second : 'a * 'a -> 'a =                             (* Returns the second element of a tuple *)
   fun (i, s) -> s

let rec append : 'a list -> 'a list -> 'a list =                        (* Adds two lists*)
   fun xs ys -> 
   match xs with
    [] -> ys                                                            (* Returns the second list if there is a empty list passed *)
    | (h::rest) -> h::append rest ys;;                                  (* Adds the head to the recursive call of itself by passing the tail *)      


(*
Ocaml pattern matching values

One cool feature of Ocaml is the ability to break apart data structures and perform pattern matching. Its used to perform computations according to the pattern
of the expression. Pattern matching can be performed on any data type. The keyword "match _ with" is used to implement pattern matching. Pattern matching behaves 
like a switch statement. The bar operator '|' indicates that pattern matching is being used. Ocaml executes a left-to-right, top-to-bottom algorithm. So when the 
compiler encounters a '|' , it checks if the expression to the right of the bar is satisfied. If not, it goes to the next pattern. [3]
*)

let rec member : 'a -> 'a list -> bool =                             (* Checks if a given element is present in the given list *)
   fun elem xs ->
   match xs with
   [] -> false                                                       (* Returns false if the given element is not there in the list *)      
   | (x::rest) when x =elem -> true                                  (* Returns true if the head is the given element to be found *)   
   | (x::rest) -> member elem rest                                   (* Calls itself recursively to iterate through the list *)   


(*
Named and Anonymous Functions

Functions are data items that takes an argument and returns a data item of the given type. Named functions are just functions that have a name. But some
functions are created just to pass them as an argument to another function, and Ocaml has simplified this. Anonymous functions are functions that dont have 
a name so that they cannot be assigned to any value. These anonymous functions are used to pass as arguments to another function.
The difference between named and anonymous functions is that named functions have a return type, but anonymous functions dont have a return type. The return 
type of anonymous functions is inferred automatically by the compiler. The 'fun' expression creates an anonymous function.
*)

let cube : int -> int =       (* named function *)
fun x ->                      (* anonynous function *)
x*x*x;;

(*
Recursive functions

Recursion is the concept of calling a function from within itself. A recursive function is defined using the keyword 'rec'. A recursive function requires two
properties:
   1. A base case
   2. A set of rules that reduces other cases to the base case.[4]   
*)

let rec length: 'a list -> int =                      (* Recursive function to find the length of a list *)
   fun xs ->
   match xs with
   [] -> 0                                            (* Returns 0 if its an empty list *)
   | (x::rest) -> 1 + length rest;;                   (* Adds 1 to the recursive call of itself by passing the tail of the list *)   


(*
Unit and property based tests

A test is used to examine the functionality of the function and to compare the expected ouput with the output of the function.

Unit testing:
   A unit test is a small test suite for the function to test its functionality. This type of testing is used to compute minimal functionalities of a 
   function.
   Example:
   let add_test1 _test_ctxt =
      assert_equal 9 (add 5 4)
   More examples can be found in the EssayTests.ml

Property-based testing:
   Property-based testing is a big test suite for the function. Instead of doing multiple unit tests for a function, it applies many input values to test
   the function. The properties that the function must hold are defined in these tests. Property testing uses a generator to test different inputs.
   More examples can be found in the EssayTests.ml

*)

(* REFERENCES
[1]https://stackoverflow.com/ocaml
[2]https://learn-eu-central-1-prod-fleet01-xythos.content.blackboardcdn.com/5b44cfad90f2e/
[3]https://ocaml.org/learn/tutorials/data_types_and_matching.html#Pattern-matching-on-datatypes
[4]https://haifengl.wordpress.com/2014/07/14/ocaml-recursion/

*)